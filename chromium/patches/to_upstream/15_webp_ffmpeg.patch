diff -wurp -N orig/libavformat/Makefile ffmpeg/libavformat/Makefile
--- orig/libavformat/Makefile	2011-07-12 20:48:57.664216904 -0700
+++ ffmpeg/libavformat/Makefile	2011-07-12 20:48:57.714181059 -0700
@@ -299,6 +299,8 @@ OBJS-$(CONFIG_WC3_DEMUXER)              
 OBJS-$(CONFIG_WEBM_MUXER)                += matroskaenc.o matroska.o \
                                             riff.o isom.o avc.o \
                                             flacenc_header.o avlanguage.o
+OBJS-$(CONFIG_WEBP_DEMUXER)              += webpdec.o webp.o
+OBJS-$(CONFIG_WEBP_MUXER)                += webpenc.o webp.o
 OBJS-$(CONFIG_WSAUD_DEMUXER)             += westwood.o
 OBJS-$(CONFIG_WSVQA_DEMUXER)             += westwood.o
 OBJS-$(CONFIG_WTV_DEMUXER)               += wtvdec.o wtv.o asfdec.o asf.o asfcrypt.o \
diff -wurp -N orig/libavformat/allformats.c ffmpeg/libavformat/allformats.c
--- orig/libavformat/allformats.c	2011-07-12 20:48:57.664216904 -0700
+++ ffmpeg/libavformat/allformats.c	2011-07-12 20:48:57.714181059 -0700
@@ -222,6 +222,7 @@ void av_register_all(void)
     REGISTER_MUXDEMUX (WAV, wav);
     REGISTER_DEMUXER  (WC3, wc3);
     REGISTER_MUXER    (WEBM, webm);
+    REGISTER_MUXDEMUX (WEBP, webp);
     REGISTER_DEMUXER  (WSAUD, wsaud);
     REGISTER_DEMUXER  (WSVQA, wsvqa);
     REGISTER_DEMUXER  (WTV, wtv);
diff -wurp -N orig/libavformat/webp.c ffmpeg/libavformat/webp.c
--- orig/libavformat/webp.c	1969-12-31 16:00:00.000000000 -0800
+++ ffmpeg/libavformat/webp.c	2011-07-12 20:48:57.714181059 -0700
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2010, Google, Inc.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/*
+ * @file
+ * common code for WebP muxer/demuxer
+ */
+
+#include "webp.h"
+
+const AVMetadataConv ff_webp_metadata_conv[] = {
+    { "IART", "artist" },
+    { "ICOP", "copyright" },
+    { "INAM", "title" },
+    { "ICMT", "comment" },
+    { 0 }
+};
diff -wurp -N orig/libavformat/webp.h ffmpeg/libavformat/webp.h
--- orig/libavformat/webp.h	1969-12-31 16:00:00.000000000 -0800
+++ ffmpeg/libavformat/webp.h	2011-07-12 20:48:57.714181059 -0700
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2010, Google, Inc.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/*
+ * @file
+ * common header for WebP muxer/demuxer
+ */
+
+#ifndef AVFORMAT_WEBP_H
+#define AVFORMAT_WEBP_H
+
+#include "avformat.h"
+#include "riff.h"
+#include "metadata.h"
+
+extern const AVMetadataConv ff_webp_metadata_conv[];
+
+#endif /* AVFORMAT_WEBP_H */
diff -wurp -N orig/libavformat/webpdec.c ffmpeg/libavformat/webpdec.c
--- orig/libavformat/webpdec.c	1969-12-31 16:00:00.000000000 -0800
+++ ffmpeg/libavformat/webpdec.c	2011-07-12 20:48:57.714181059 -0700
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2010, Google, Inc.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/*
+ * @file
+ * WebP demuxer
+ * http://code.google.com/p/webp
+ *
+ * supports metadata: artist, copyright, title, comment
+ * Encoding/decoding examples:
+ *  ffmpeg -i my_image
+ *     -metadata artist=me -metadata title="sunset"
+ *     -metadata copyright=2010 -metadata comment="nice pic!"
+ *     -profile 1 -qmin 5 my_image.webp
+ *  ffmpeg -i my_image.webp -y my_image.png
+ */
+
+#include "webp.h"
+#include "libavutil/intreadwrite.h"
+
+static const AVCodecTag webp_codec_tags[] = {
+    { CODEC_ID_VP8,    MKTAG('V', 'P', '8', ' ') },
+    { CODEC_ID_NONE,   0 }
+};
+
+static int probe(AVProbeData *p)
+{
+    if (!memcmp(p->buf, "RIFF", 4) && !memcmp(p->buf + 8, "WEBP", 4))
+        return AVPROBE_SCORE_MAX;
+
+    return 0;
+}
+
+static int read_header(AVFormatContext *s, AVFormatParameters *ap)
+{
+    AVStream *st;
+    uint32_t riff_size;
+
+    if (get_le32(s->pb) != AV_RL32("RIFF"))
+        return AVERROR(EINVAL);
+    riff_size = get_le32(s->pb);
+    if (get_le32(s->pb) != AV_RL32("WEBP"))
+        return AVERROR(EINVAL);
+
+    st = av_new_stream(s, 0);
+    if (!st)
+        return AVERROR(ENOMEM);
+
+    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
+    st->codec->codec_tag  = AV_RL32("VP8 ");
+    st->codec->codec_id   = ff_codec_get_id(webp_codec_tags,
+                                            st->codec->codec_tag);
+    av_set_pts_info(st, 24, 1, 1000);
+
+    return 0;
+}
+
+static int set_metadata(ByteIOContext* pb, AVMetadata** metadata,
+                        const char* generic_key, uint32_t size)
+{
+    char* const value = av_malloc(size + 1);
+    if (!value)
+        return AVERROR(ENOMEM);
+    if (get_buffer(pb, value, size) < 0)
+        return AVERROR(EINVAL);
+    value[size] = 0;
+    if (av_metadata_set2(metadata, generic_key, value, 0))
+        return AVERROR(EINVAL);
+    av_free(value);
+    return size;
+}
+
+static int read_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    int ret = -1;
+    AVStream *stream = s->streams[pkt->stream_index];
+    uint32_t tag = get_le32(s->pb);
+    uint32_t chunk_size = get_le32(s->pb);
+    if (tag == stream->codec->codec_tag) {
+        ret = av_get_packet(s->pb, pkt, chunk_size);
+        pkt->flags |= AV_PKT_FLAG_KEY;
+    }
+    else {
+        int i;
+        for (i = 0; ff_webp_metadata_conv[i].native; ++i) {
+            const char* native_tag = ff_webp_metadata_conv[i].native;
+            if (tag == AV_RL32(native_tag)) {
+                ret = set_metadata(s->pb, &stream->metadata,
+                                   ff_webp_metadata_conv[i].generic,
+                                   chunk_size);
+                break;
+            }
+        }
+    }
+    return ret;
+}
+
+static int read_close(struct AVFormatContext *s)
+{
+    return 0;
+}
+
+AVInputFormat webp_demuxer = {
+    .name           = "webp",
+    .long_name      = NULL_IF_CONFIG_SMALL("WebP"),
+    .priv_data_size = 0,
+    .read_probe     = probe,
+    .read_header    = read_header,
+    .read_packet    = read_packet,
+    .read_close     = read_close,
+    .flags          = AVFMT_GENERIC_INDEX,
+    .extensions     = "webp",
+    .value          = CODEC_ID_VP8,
+    .codec_tag      = (const AVCodecTag*[]){webp_codec_tags, 0},
+};
diff -wurp -N orig/libavformat/webpenc.c ffmpeg/libavformat/webpenc.c
--- orig/libavformat/webpenc.c	1969-12-31 16:00:00.000000000 -0800
+++ ffmpeg/libavformat/webpenc.c	2011-07-12 20:48:57.714181059 -0700
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2010, Google, Inc.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/*
+ * @file
+ * WebP muxer
+ * http://code.google.com/p/webp
+ *
+ * supports metadata: artist, copyright, title, comment
+ * Encoding/decoding examples:
+ *  ffmpeg -i my_image
+ *     -metadata artist=me -metadata title="sunset"
+ *     -metadata copyright=2010 -metadata comment="nice pic!"
+ *     -profile 1 -qmin 5 my_image.webp
+ *  ffmpeg -i my_image.webp -y my_image.png
+ */
+
+#include "webp.h"
+
+typedef struct {
+  uint64_t riff_start;
+} WEBPContext;
+
+static int write_header(AVFormatContext *s)
+{
+    ByteIOContext *pb = s->pb;
+    WEBPContext *webp = s->priv_data;
+    AVStream *stream;
+    AVCodecContext *codec;
+
+    if (s->nb_streams != 1) {
+        av_log(s, AV_LOG_ERROR, "muxer only support 1 video stream.");
+        return AVERROR(EINVAL);
+    }
+    stream = s->streams[0];
+    codec = stream->codec;
+    if (codec->codec_type != AVMEDIA_TYPE_VIDEO)
+        return AVERROR(EINVAL);
+    if (codec->codec_id != CODEC_ID_VP8)
+       return AVERROR(EINVAL);
+
+    webp->riff_start = ff_start_tag(pb, "RIFF");
+    put_tag(pb, "WEBP");
+    return 0;
+}
+
+static int write_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    AVStream *stream = s->streams[pkt->stream_index];
+    AVCodecContext *codec = stream->codec;
+    ByteIOContext *pb = s->pb;
+    uint64_t vp8_start;
+
+    if (codec->codec_id != CODEC_ID_VP8) {
+        av_log(s, AV_LOG_ERROR, "muxer only supports VP8 codec.");
+        return AVERROR(EINVAL);
+    }
+    vp8_start = ff_start_tag(pb, "VP8 ");
+    put_buffer(pb, pkt->data, pkt->size);
+    if (pkt->size & 1) put_byte(pb, 0);   // pad
+    ff_end_tag(pb, vp8_start);
+    put_flush_packet(pb);
+    return 0;
+}
+
+static void put_metadata(AVFormatContext *s,
+                         const AVMetadataConv* metadata)
+{
+    ByteIOContext *pb = s->pb;
+    AVMetadataTag *t;
+    uint64_t pos;
+    int len;
+    t = av_metadata_get(s->metadata, metadata->generic, NULL, 0);
+    if (!t) return;
+    pos = ff_start_tag(pb, metadata->native);
+    len = strlen(t->value) + 1;
+    put_buffer(pb, t->value, len);
+    if (len & 1) put_byte(pb, 0);   // pad
+    ff_end_tag(pb, pos);
+}
+
+static int write_trailer(AVFormatContext *s)
+{
+    ByteIOContext *pb = s->pb;
+    WEBPContext *webp = s->priv_data;
+    int i;
+    for (i = 0; ff_webp_metadata_conv[i].native; ++i) {
+        put_metadata(s, &ff_webp_metadata_conv[i]);
+    }
+    ff_end_tag(pb, webp->riff_start);
+    put_flush_packet(pb);
+    return 0;
+}
+
+AVOutputFormat webp_muxer = {
+    .name           = "webp",
+    .long_name      = NULL_IF_CONFIG_SMALL("WebP"),
+    .mime_type      = "image/webp",
+    .extensions     = "webp",
+    .priv_data_size = sizeof(WEBPContext),
+    .audio_codec    = CODEC_ID_NONE,
+    .video_codec    = CODEC_ID_VP8,
+    .write_header   = write_header,
+    .write_packet   = write_packet,
+    .write_trailer  = write_trailer,
+};
