From 3996ee13d51a4f42474bb2c7cb599fcf3b244b54 Mon Sep 17 00:00:00 2001
From: Dale Curtis <dalecurtis@chromium.org>
Date: Thu, 9 Feb 2012 15:34:55 -0800
Subject: [PATCH] Fix valgrind and asan memory leaks and crashes.

Lots of fixes and patch cleanup.  All these fixes are necessary to get
ffmpeg_regression_tests passing w/o crashes on ia32/x64 platforms.

Both utils.c changes are likely incompatible with all codecs, the
codec->close() and iformat->read_close() methods for desired codecs must
be sanitized to ensure they are not double-free'ing.

BUG=none
TEST=ffmpeg_regression_tests
---
 chromium/patches/README                            |   25 +++++++-
 .../patches/to_upstream/01_static_pthread_O2.patch |   72 --------------------
 chromium/patches/to_upstream/55_h264_nal.patch     |   64 +++--------------
 libavcodec/pthread.c                               |    1 +
 libavcodec/utils.c                                 |    2 +
 libavcodec/vorbisdec.c                             |   50 ++++++++------
 libavcodec/vp3.c                                   |    4 +-
 libavcodec/vp8.c                                   |    2 +-
 libavformat/mov.c                                  |    6 ++
 libavformat/oggdec.c                               |   11 +++-
 libavformat/oggdec.h                               |    5 ++
 libavformat/oggparsetheora.c                       |    1 +
 libavformat/oggparsevorbis.c                       |    6 --
 libavformat/utils.c                                |    4 +-
 14 files changed, 95 insertions(+), 158 deletions(-)
 delete mode 100644 chromium/patches/to_upstream/01_static_pthread_O2.patch

diff --git a/chromium/patches/README b/chromium/patches/README
index b2df201..edd2f1e 100644
--- a/chromium/patches/README
+++ b/chromium/patches/README
@@ -1,4 +1,23 @@
-Current Status as of November 28, 2011
+Current Status as of Feb 13, 2012
+
+
+Patches added with the new GIT workflow:
+
+3f94559a9b2ad2e2bad5ad5de11c0872b48a4cd9 - libavutil/attributes.h
+  dalecurtis: Disables deprecated attribute for Chromium. Tracking bug here:
+  http://crbug.com/112673
+
+98c46c76a34921edbe6e4f5658c30fe479502b6e - <multiple files>
+  dalecurtis: Removes "#define UNCHECKED_BITSTREAM_READER 1" from all codecs
+  defining it. In Chromium, all codecs should use the safe bitstream reader.
+
+https://chromiumcodereview.appspot.com/9373002/ - <multiple files>
+  dalecurtis: Lots of fixes for crashes and memory leaks found during regression
+  testing after roll to ea4037162fb0afa871e5312a7b23c828d2b85066.  See code
+  review at https://chromiumcodereview.appspot.com/9373002/ for more details.
+
+
+Patches still existing from the pre-GIT workflow:
 
 to_upstream/
 05_respect_flac_dirac_configure.patch
@@ -20,6 +39,8 @@ to_upstream/
 35_oggdec_duration.patch
   scherkus: Reverts FFmpeg commit 5901cd6236d97b34fe59a47ba0fd6da8f647d1f1
   which regressed duration calculation.
+  dalecurtis: still broken after ffmpeg roll to
+  ea4037162fb0afa871e5312a7b23c828d2b85066.
 
 53_matroska_codec_config.patch
   cevans: avoid compiling in codec-specific code in Matroska if the codecs are
@@ -30,6 +51,8 @@ to_upstream/
 
 55_h264_nal.patch
   cevans: avoid OOB reads.
+  dalecurtis: partially upstreamed already. updated patch file with non-upstream
+  bits.
 
 ugly/
 
diff --git a/chromium/patches/to_upstream/01_static_pthread_O2.patch b/chromium/patches/to_upstream/01_static_pthread_O2.patch
deleted file mode 100644
index 399e0c3..0000000
--- a/chromium/patches/to_upstream/01_static_pthread_O2.patch
+++ /dev/null
@@ -1,72 +0,0 @@
-diff -wurp -N orig/configure ffmpeg/configure
---- orig/configure	2011-07-12 20:46:31.912987236 -0700
-+++ ffmpeg/configure	2011-07-12 20:46:32.033313125 -0700
-@@ -1946,7 +1946,7 @@ elif $cc -v 2>&1 | grep -qi ^gcc; then
-         CC_DEPFLAGS='-MMD -MF $(@:.o=.d) -MT $@'
-         AS_DEPFLAGS='-MMD -MF $(@:.o=.d) -MT $@'
-     fi
--    speed_cflags='-O3'
-+    speed_cflags='-O2'
-     size_cflags='-Os'
- elif $cc --version 2>/dev/null | grep -q Intel; then
-     cc_type=icc
-@@ -2098,6 +2098,7 @@ elif $cc -v 2>&1 | grep -q Open64; then
-     cc_ident=$($cc -v 2>&1 | head -n1 | tr -d :)
-     CC_DEPFLAGS='-MMD -MF $(@:.o=.d) -MT $@'
-     AS_DEPFLAGS='-MMD -MF $(@:.o=.d) -MT $@'
-+# O2 produces smaller/faster code on P4 and same performance on Core/Atom.
-     speed_cflags='-O2'
-     size_cflags='-Os'
-     filter_cflags='filter_out -Wdisabled-optimization|-Wtype-limits|-fno-signed-zeros'
-@@ -2852,6 +2853,10 @@ if ! disabled pthreads && ! enabled w32t
-         add_extralibs -pthreads
-     elif check_func pthread_create -lpthreadGC2; then
-         add_extralibs -lpthreadGC2
-+# static pthreads improves startup time
-+    elif check_func pthread_create -lpthreadGC2 -lws2_32; then
-+        add_cflags -DPTW32_STATIC_LIB
-+        add_extralibs -lpthreadGC2 -lws2_32
-     elif ! check_lib pthread.h pthread_create -lpthread; then
-         disable pthreads
-     fi
-@@ -3085,7 +3090,8 @@ elif enabled ccc; then
- elif enabled gcc; then
-     check_cflags -fno-tree-vectorize
-     check_cflags -Werror=implicit-function-declaration
--    check_cflags -Werror=missing-prototypes
-+# Removed to allow msys gcc 4.2.1-sjlj to compile
-+#   check_cflags -Werror=missing-prototypes
- elif enabled llvm_gcc; then
-     check_cflags -mllvm -stack-alignment=16
- elif enabled clang; then
-diff -wurp -N orig/libavcodec/allcodecs.c ffmpeg/libavcodec/allcodecs.c
---- orig/libavcodec/allcodecs.c	2011-07-12 20:46:31.952992143 -0700
-+++ ffmpeg/libavcodec/allcodecs.c	2011-07-12 20:46:32.033313125 -0700
-@@ -45,6 +45,15 @@
-           extern AVBitStreamFilter ff_##x##_bsf; \
-           if(CONFIG_##X##_BSF)     av_register_bitstream_filter(&ff_##x##_bsf); }
- 
-+#ifdef PTW32_STATIC_LIB
-+#include "pthread.h"
-+static void detach_ptw32(void)
-+{
-+    pthread_win32_thread_detach_np();
-+    pthread_win32_process_detach_np();
-+}
-+#endif
-+
- void avcodec_register_all(void)
- {
-     static int initialized;
-@@ -53,6 +62,11 @@ void avcodec_register_all(void)
-         return;
-     initialized = 1;
- 
-+#ifdef PTW32_STATIC_LIB
-+    pthread_win32_process_attach_np();
-+    pthread_win32_thread_attach_np();
-+    atexit(detach_ptw32);
-+#endif
-     /* hardware accelerators */
-     REGISTER_HWACCEL (H263_VAAPI, h263_vaapi);
-     REGISTER_HWACCEL (H264_DXVA2, h264_dxva2);
diff --git a/chromium/patches/to_upstream/55_h264_nal.patch b/chromium/patches/to_upstream/55_h264_nal.patch
index d464493..8c2b6d5 100644
--- a/chromium/patches/to_upstream/55_h264_nal.patch
+++ b/chromium/patches/to_upstream/55_h264_nal.patch
@@ -1,67 +1,27 @@
-diff -wurp -N orig/libavcodec/h264.c ffmpeg/libavcodec/h264.c
---- orig/libavcodec/h264.c	2012-02-06 14:02:09.990431439 -0800
-+++ ffmpeg/libavcodec/h264.c	2012-02-06 14:06:11.752827405 -0800
-@@ -988,12 +988,13 @@ int ff_h264_decode_extradata(H264Context
-     AVCodecContext *avctx = h->s.avctx;
- 
-     if(avctx->extradata[0] == 1){
--        int i, cnt, nalsize;
-+        int i, cnt, nalsize, size_left;
-         unsigned char *p = avctx->extradata;
-+        size_left = avctx->extradata_size;
- 
-         h->is_avc = 1;
- 
--        if(avctx->extradata_size < 7) {
-+        if(size_left < 7) {
-             av_log(avctx, AV_LOG_ERROR, "avcC too short\n");
-             return -1;
-         }
-@@ -1003,23 +1004,47 @@ int ff_h264_decode_extradata(H264Context
-         // Decode sps from avcC
+diff --git a/libavcodec/h264.c b/libavcodec/h264.c
+index 7a16bda..2fea444 100644
+--- a/libavcodec/h264.c
++++ b/libavcodec/h264.c
+@@ -1097,6 +1095,8 @@ int ff_h264_decode_extradata(H264Context *h, const uint8_t *buf, int size)
          cnt = *(p+5) & 0x1f; // Number of sps
          p += 6;
-+        size_left -= 6;
          for (i = 0; i < cnt; i++) {
-+            if (size_left < 2) {
-+                av_log(avctx, AV_LOG_ERROR, "Cannot read sps nalsize\n");
++            if(size - (p-buf) < 2)
 +                return -1;
-+            }
              nalsize = AV_RB16(p) + 2;
-+            if (size_left < nalsize) {
-+                av_log(avctx, AV_LOG_ERROR, "sps nalsize too big\n");
-+                return -1;
-+            }
-             if(decode_nal_units(h, p, nalsize) < 0) {
-                 av_log(avctx, AV_LOG_ERROR, "Decoding sps %d from avcC failed\n", i);
+             if(nalsize > size - (p-buf))
                  return -1;
+@@ -1106,9 +1106,13 @@ int ff_h264_decode_extradata(H264Context *h, const uint8_t *buf, int size)
              }
              p += nalsize;
-+            size_left -= nalsize;
          }
-         // Decode pps from avcC
-+        if(!size_left) {
-+            av_log(avctx, AV_LOG_ERROR, "Cannot read pps count\n");
++        if(size - (p-buf) <= 0)
 +            return -1;
-+        }
+         // Decode pps from avcC
          cnt = *(p++); // Number of pps
-+        --size_left;
          for (i = 0; i < cnt; i++) {
-+            if (size_left < 2) {
-+                av_log(avctx, AV_LOG_ERROR, "Cannot read pps nalsize\n");
++            if(size - (p-buf) < 2)
 +                return -1;
-+            }
              nalsize = AV_RB16(p) + 2;
-+            if (size_left < nalsize) {
-+                av_log(avctx, AV_LOG_ERROR, "pps nalsize too big\n");
-+                return -1;
-+            }
-             if (decode_nal_units(h, p, nalsize) < 0) {
-                 av_log(avctx, AV_LOG_ERROR, "Decoding pps %d from avcC failed\n", i);
+             if(nalsize > size - (p-buf))
                  return -1;
-             }
-             p += nalsize;
-+            size_left -= nalsize;
-         }
-         // Now store right nal length size, that will be use to parse all other nals
-         h->nal_length_size = (avctx->extradata[4] & 0x03) + 1;
diff --git a/libavcodec/pthread.c b/libavcodec/pthread.c
index 6ae763d..e90a0a0 100644
--- a/libavcodec/pthread.c
+++ b/libavcodec/pthread.c
@@ -610,6 +610,7 @@ int ff_thread_decode_frame(AVCodecContext *avctx,
      * Submit a packet to the next decoding thread.
      */
 
+    if (fctx->next_decoding >= avctx->thread_count) return err;
     p = &fctx->threads[fctx->next_decoding];
     err = update_context_from_user(p->avctx, avctx);
     if (err) return err;
diff --git a/libavcodec/utils.c b/libavcodec/utils.c
index 9e31d9e..72e25dc 100644
--- a/libavcodec/utils.c
+++ b/libavcodec/utils.c
@@ -874,6 +874,8 @@ int attribute_align_arg avcodec_open2(AVCodecContext *avctx, AVCodec *codec, AVD
     if(avctx->codec->init && !(avctx->active_thread_type&FF_THREAD_FRAME)){
         ret = avctx->codec->init(avctx);
         if (ret < 0) {
+            if(avctx->codec->close)
+                avctx->codec->close(avctx);
             goto free_and_end;
         }
     }
diff --git a/libavcodec/vorbisdec.c b/libavcodec/vorbisdec.c
index f71d606..443c0aa 100644
--- a/libavcodec/vorbisdec.c
+++ b/libavcodec/vorbisdec.c
@@ -197,38 +197,46 @@ static void vorbis_free(vorbis_context *vc)
     av_freep(&vc->channel_floors);
     av_freep(&vc->saved);
 
-    for (i = 0; i < vc->residue_count; i++)
-        av_free(vc->residues[i].classifs);
-    av_freep(&vc->residues);
+    if (vc->residues) {
+        for (i = 0; i < vc->residue_count; i++)
+            av_free(vc->residues[i].classifs);
+        av_freep(&vc->residues);
+    }
     av_freep(&vc->modes);
 
     ff_mdct_end(&vc->mdct[0]);
     ff_mdct_end(&vc->mdct[1]);
 
-    for (i = 0; i < vc->codebook_count; ++i) {
-        av_free(vc->codebooks[i].codevectors);
-        free_vlc(&vc->codebooks[i].vlc);
+    if (vc->codebooks) {
+        for (i = 0; i < vc->codebook_count; ++i) {
+            av_free(vc->codebooks[i].codevectors);
+            free_vlc(&vc->codebooks[i].vlc);
+        }
+        av_freep(&vc->codebooks);
     }
-    av_freep(&vc->codebooks);
 
-    for (i = 0; i < vc->floor_count; ++i) {
-        if (vc->floors[i].floor_type == 0) {
-            av_free(vc->floors[i].data.t0.map[0]);
-            av_free(vc->floors[i].data.t0.map[1]);
-            av_free(vc->floors[i].data.t0.book_list);
-            av_free(vc->floors[i].data.t0.lsp);
-        } else {
-            av_free(vc->floors[i].data.t1.list);
+    if (vc->floors) {
+        for (i = 0; i < vc->floor_count; ++i) {
+            if (vc->floors[i].floor_type == 0) {
+                av_free(vc->floors[i].data.t0.map[0]);
+                av_free(vc->floors[i].data.t0.map[1]);
+                av_free(vc->floors[i].data.t0.book_list);
+                av_free(vc->floors[i].data.t0.lsp);
+            } else {
+                av_free(vc->floors[i].data.t1.list);
+            }
         }
+        av_freep(&vc->floors);
     }
-    av_freep(&vc->floors);
 
-    for (i = 0; i < vc->mapping_count; ++i) {
-        av_free(vc->mappings[i].magnitude);
-        av_free(vc->mappings[i].angle);
-        av_free(vc->mappings[i].mux);
+    if (vc->mappings) {
+        for (i = 0; i < vc->mapping_count; ++i) {
+            av_free(vc->mappings[i].magnitude);
+            av_free(vc->mappings[i].angle);
+            av_free(vc->mappings[i].mux);
+        }
+        av_freep(&vc->mappings);
     }
-    av_freep(&vc->mappings);
 }
 
 // Parse setup header -------------------------------------------------
diff --git a/libavcodec/vp3.c b/libavcodec/vp3.c
index b5daafc..3d79a7d 100644
--- a/libavcodec/vp3.c
+++ b/libavcodec/vp3.c
@@ -399,7 +399,7 @@ static void init_loop_filter(Vp3DecodeContext *s)
 
     /* set up the bounding values */
     memset(s->bounding_values_array, 0, 256 * sizeof(int));
-    for (x = 0; x < filter_limit; x++) {
+    for (x = 0; x < filter_limit && x < 128; x++) {
         bounding_values[-x] = -x;
         bounding_values[x] = x;
     }
@@ -1630,7 +1630,7 @@ static av_cold int allocate_tables(AVCodecContext *avctx)
     s->superblock_coding = av_malloc(s->superblock_count);
     s->all_fragments = av_malloc(s->fragment_count * sizeof(Vp3Fragment));
     s->coded_fragment_list[0] = av_malloc(s->fragment_count * sizeof(int));
-    s->dct_tokens_base = av_malloc(64*s->fragment_count * sizeof(*s->dct_tokens_base));
+    s->dct_tokens_base = av_mallocz(64*s->fragment_count * sizeof(*s->dct_tokens_base));
     s->motion_val[0] = av_malloc(y_fragment_count * sizeof(*s->motion_val[0]));
     s->motion_val[1] = av_malloc(c_fragment_count * sizeof(*s->motion_val[1]));
 
diff --git a/libavcodec/vp8.c b/libavcodec/vp8.c
index 4728393..b23dae4 100644
--- a/libavcodec/vp8.c
+++ b/libavcodec/vp8.c
@@ -124,7 +124,7 @@ static int update_dimensions(VP8Context *s, int width, int height)
     s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));
     s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));
     s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);
-    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));
+    s->top_nnz                 = av_mallocz((s->mb_width+1)*sizeof(*s->top_nnz));
     s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));
 
     if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||
diff --git a/libavformat/mov.c b/libavformat/mov.c
index c2c980f..81e9642 100644
--- a/libavformat/mov.c
+++ b/libavformat/mov.c
@@ -2962,6 +2962,12 @@ static int mov_read_close(AVFormatContext *s)
         av_freep(&sc->drefs);
         if (sc->pb && sc->pb != s->pb)
             avio_close(sc->pb);
+        av_freep(&sc->chunk_offsets);
+        av_freep(&sc->keyframes);
+        av_freep(&sc->sample_sizes);
+        av_freep(&sc->stps_data);
+        av_freep(&sc->stsc_data);
+        av_freep(&sc->stts_data);
     }
 
     if (mov->dv_demux) {
diff --git a/libavformat/oggdec.c b/libavformat/oggdec.c
index 0e0b838..81066ca 100644
--- a/libavformat/oggdec.c
+++ b/libavformat/oggdec.c
@@ -629,8 +629,15 @@ static int ogg_read_close(AVFormatContext *s)
     int i;
 
     for (i = 0; i < ogg->nstreams; i++){
-        av_free (ogg->streams[i].buf);
-        av_free (ogg->streams[i].private);
+        struct ogg_stream os = ogg->streams[i];
+        struct oggvorbis_private *priv = os.private;
+        if (priv && priv->packet && os.buf) {
+            int pkt_type = os.buf[os.pstart];
+            if ((pkt_type == 1 || pkt_type == 3) && priv->len[pkt_type >> 1] > 0)
+               av_freep (&priv->packet[pkt_type >> 1]);
+        }
+        av_free (os.buf);
+        av_free (os.private);
     }
     av_free (ogg->streams);
     return 0;
diff --git a/libavformat/oggdec.h b/libavformat/oggdec.h
index 7f5452f..4d5d8cb 100644
--- a/libavformat/oggdec.h
+++ b/libavformat/oggdec.h
@@ -95,6 +95,11 @@ struct ogg {
     struct ogg_state *state;
 };
 
+struct oggvorbis_private {
+    unsigned int len[3];
+    unsigned char *packet[3];
+};
+
 #define OGG_FLAG_CONT 1
 #define OGG_FLAG_BOS  2
 #define OGG_FLAG_EOS  4
diff --git a/libavformat/oggparsetheora.c b/libavformat/oggparsetheora.c
index 993db3e..9779a16 100644
--- a/libavformat/oggparsetheora.c
+++ b/libavformat/oggparsetheora.c
@@ -130,6 +130,7 @@ theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)
     struct ogg *ogg = ctx->priv_data;
     struct ogg_stream *os = ogg->streams + idx;
     struct theora_params *thp = os->private;
+    if (!thp) return 0;
     uint64_t iframe = gp >> thp->gpshift;
     uint64_t pframe = gp & thp->gpmask;
 
diff --git a/libavformat/oggparsevorbis.c b/libavformat/oggparsevorbis.c
index ba9b348..755c90b 100644
--- a/libavformat/oggparsevorbis.c
+++ b/libavformat/oggparsevorbis.c
@@ -159,12 +159,6 @@ ff_vorbis_comment(AVFormatContext * as, AVDictionary **m, const uint8_t *buf, in
  * [framing_flag] = read one bit | Not Used
  *    */
 
-struct oggvorbis_private {
-    unsigned int len[3];
-    unsigned char *packet[3];
-};
-
-
 static unsigned int
 fixup_vorbis_headers(AVFormatContext * as, struct oggvorbis_private *priv,
                      uint8_t **buf)
diff --git a/libavformat/utils.c b/libavformat/utils.c
index 71baf58..8833a0b 100644
--- a/libavformat/utils.c
+++ b/libavformat/utils.c
@@ -595,8 +595,10 @@ int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputForma
         ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC);
 
     if (!(s->flags&AVFMT_FLAG_PRIV_OPT) && s->iformat->read_header)
-        if ((ret = s->iformat->read_header(s)) < 0)
+        if ((ret = s->iformat->read_header(s)) < 0) {
+            s->iformat->read_close(s);
             goto fail;
+        }
 
     if (!(s->flags&AVFMT_FLAG_PRIV_OPT) && s->pb && !s->data_offset)
         s->data_offset = avio_tell(s->pb);
-- 
1.7.7.3

